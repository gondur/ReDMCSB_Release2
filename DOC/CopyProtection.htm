<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Copy Protection</title>
<meta http-equiv="content-type" content="text/html;charset=utf-8" />
<link type="text/css" rel="stylesheet" media="all" href="style.css" />
</head>
<body>
<h1>Copy Protection</h1>
<p>This document describes the software side of the copy protection. The game implements 6 copy protection schemes (named COPYPROTECTIONA to COPYPROTECTIONE) to make sure that the game disk is original and has not been tampered with. The copy protection schemes are spread over many functions and variables in the program to make it as hard as possible to find and crack them all.</p>
<ul><li>One scheme (A) is very simple and checks for the presence of a specific command line parameter.</li>
<li>Five schemes (B, C, D, E, F) read a copy protected sector from the floppy disk and make sure it is original. There are two copy protected sectors (sectors that cannot be copied using consumer grade hardware) on the floppy disk: sectors 7 and 247 on track 0, side 0. Each scheme performs its check in a particular way:<ul>
<li>Scheme B reads both sectors 10 and 247 and checks the contents of sector 247.</li>
<li>Scheme C checks fuzzy bits in sector 7 and uses several checksums (using 3 different algorithms) on the code of 2 functions to detect if they have been modified.</li>
<li>Scheme D reads sector 247 from time to time. This scheme is mixed with the code to play sounds.</li>
<li>Schemes E and F read sector 7 and check for the presence of fuzzy bits. Both use code hidden as bitmaps in <code>GRAPHICS.DAT</code>: regular functions in the game are dynamically patched to run these hidden subroutines and then the functions are restored to their original form so that the copy protection code is harder to find and neutralize. Scheme E is mixed with code to draw the dungeon view. Scheme F is mixed with various functions and triggered when the party moves to another map.</li></ul></li></ul>
<p>In the source code files, all code related to the copy protection is contained within conditional compilation directives using the keyword <code>NOCOPYPROTECTION</code>. If this constant is defined then the game is compiled withtout any copy protection.</p>
<ul><li><a href="#ReadingCopyProtectedSectors">Reading copy protected sectors</a></li>
<li><a href="#COPYPROTECTIONA">Copy protection A</a></li>
<li><a href="#COPYPROTECTIONB">Copy protection B</a></li>
<li><a href="#COPYPROTECTIONC">Copy protection C</a></li>
<li><a href="#COPYPROTECTIOND">Copy protection D</a></li>
<li><a href="#COPYPROTECTIONE">Copy protection E</a></li>
<li><a href="#COPYPROTECTIONF">Copy protection F</a></li></ul>
<h2><a name="ReadingCopyProtectedSectors">Reading copy protected sectors</a></h2>
<p>Each time the game needs to read a copy protected sector, it uses one of two methods:</p>
<ul><li>Call the built-in XBIOS function <code>Floprd()</code> with appropriate parameters including which sector to read and where to store the sector contents in memory. When this function returns the requested sector is immediately available in the specified memory buffer.</li>
<li>Call custom subroutines written in assembly code. These calls are asynchronous:
<ol><li>First, a subroutine accesses the FDC (Floppy Disk Controller) chip directly to initiate the read operation and returns before the sector is actually read into the specified memory buffer. Then the main program continues running. There are two such routines in the game:
<ul><li><code>S465_qzzz_COPYPROTECTIOND_ReadSector247</code> which is part of COPYPROTECTIOND and initiates a read operation of sector 247</li>
<li>A subroutine hidden in graphic #538 which is part of COPYPROTECTIONF and initiates a read operation of sector 7</li></ul>
Both of these subroutines set <code>G624_B_FloppyDriveTurnedOn_COPYPROTECTIONDF</code> to <code>TRUE</code> and <code>G625_i_FloppyDriveDMATimeout_COPYPROTECTIONDF</code> to 259 which is the maximum number of Vertical Blank interrupts to wait for the completion of the read operation.<br/>
A flag is also set in <code>G314_i_SectorsReadRequested_COPYPROTECTIONDF</code> to indicate which copy protection sector is being read. <code>S465_qzzz_COPYPROTECTIOND_ReadSector247</code> sets the flag for sector 247 and <code>F118_xxxx_DUNGEONVIEW_DrawSquareD3C_COPYPROTECTIONF</code> sets the flag for sector 7 before the hidden code in graphic #538 is executed.<br/>
The copy protected sectors are read in <code>G643_puc_FloppyDiskReadBuffer_COPYPROTECTIONDF</code> (a 1024 bytes buffer) which is also used for reading data from the <code>GRAPHICS.DAT</code> file. In order to identify the content of this buffer, another flag is set in <code>G644_i_FloppyDiskReadBufferContentType_COPYPROTECTIONDF</code> to indicate which copy protection sector is currently stored in the buffer. <code>F064_aadz_SOUND_RequestPlay_COPYPROTECTIOND</code> sets the flag for sector 247 before calling <code>S465_qzzz_COPYPROTECTIOND_ReadSector247</code> and <code>F118_xxxx_DUNGEONVIEW_DrawSquareD3C_COPYPROTECTIONF</code> sets the flag for sector 7 before the hidden code in graphic #538 is executed.<br/>
<code>F474_xxxx_MEMORY_LoadGraphic_COPYPROTECTIONDF</code> clears <code>G644_i_FloppyDiskReadBufferContentType_COPYPROTECTIONDF</code> if it needs to read data from the floppy disk.</li>
<li>During each Vertical Blank interrupt, <code>E017_xxxx_MAIN_Exception28Handler_VerticalBlank_COPYPROTECTIONDF</code> is executed. If <code>G625_i_FloppyDriveDMATimeout_COPYPROTECTIONDF &gt; 0</code> then the subroutine <code>S080_aaat_COPYPROTECTIONDF_CheckDMATransferCompletion</code> is called to monitor the FDC and check whether the read operation has completed. This happens until the FDC indicates that the read operation is complete (with success or failure) or until <code>G625_i_FloppyDriveDMATimeout_COPYPROTECTIONDF</code> reaches 0 (this value is decremented during each interrupt to manage the timeout). The final value of <code>G625_i_FloppyDriveDMATimeout_COPYPROTECTIONDF</code> can be:
<ul><li>-8 if the requested sector was not found on the floppy disk</li>
<li>-2 if the timeout expired before the read operation was completed</li>
<li>-1 if the DMA was not configured to read a sector</li>
<li>0 if reading succeeded</li></ul>
If the read operation succeeded then <code>G314_i_SectorsReadRequested_COPYPROTECTIONDF</code> is cleared.</li>
<li>In <code>E017_xxxx_MAIN_Exception28Handler_VerticalBlank_COPYPROTECTIONDF</code>, if the read operation is complete (<code>G625_i_FloppyDriveDMATimeout_COPYPROTECTIONDF &lt;= 0</code>) and the floppy disk drive is still on (<code>G624_B_FloppyDriveTurnedOn_COPYPROTECTIONDF = TRUE</code>) then the subroutine <code>S081_aaao_COPYPROTECTIONDF_TurnOffFloppyDrive</code> is called to turn off the floppy drive and clear <code>G624_B_FloppyDriveTurnedOn_COPYPROTECTIONDF</code>.</li>
<li>In <code>S016_xxxx_MAIN_DrawMousePointerHiddenScreenAreaIfNecessary_COPYPROTECTIONDF</code> which is called by <code>E017_xxxx_MAIN_Exception28Handler_VerticalBlank_COPYPROTECTIONDF</code>, if the read sector operation failed (<code>G625_i_FloppyDriveDMATimeout_COPYPROTECTIONDF &lt; 0</code>) then the flag set in <code>G314_i_SectorsReadRequested_COPYPROTECTIONDF</code> is copied to <code>G315_i_SectorsReadFailure_COPYPROTECTIONDF</code> and <code>G314_i_SectorsReadRequested_COPYPROTECTIONDF</code> and <code>G625_i_FloppyDriveDMATimeout_COPYPROTECTIONDF</code> are reset to 0.
<code>G315_i_SectorsReadFailure_COPYPROTECTIONDF</code> contains the result of the copy protected sectors read operations: for each sector flag, 0 means success and 1 means failure.</li></ol></li></ul>
<p>Note: the calls to <code>S080_aaat_COPYPROTECTIONDF_CheckDMATransferCompletion</code> and <code>S081_aaao_COPYPROTECTIONDF_TurnOffFloppyDrive</code> in <code>E017_xxxx_MAIN_Exception28Handler_VerticalBlank_COPYPROTECTIONDF</code> are done using their absolute addresses stored in G626_pfV_<code>S080_aaat_COPYPROTECTIONDF_CheckDMATransferCompletion</code> and G627_pfV_<code>S081_aaao_COPYPROTECTIONDF_TurnOffFloppyDrive</code> and obtained by calls to <code>F211_vzzz_COPYPROTECTIONDF_GetSubroutineAbsoluteAddress</code> in either <code>F448_xxxx_MEMINIT_InitializeMemoryManager_COPYPROTECTIONADEF</code> (in Dungeon Master) or <code>F463_wzzz_START_InitializeGame_COPYPROTECTIONADEF</code> (in Chaos Strikes Back).</p>
<p>In <code>F002_xxxx_MAIN_GameLoop_COPYPROTECTIONDF</code>, every 64 ticks, if there is a copy protection sector read failure in <code>G315_i_SectorsReadFailure_COPYPROTECTIONDF</code> but not in <code>G316_i_SectorsReadPreviousFailure_COPYPROTECTIONDF</code> (the previous read succeeded) then <code>F428_AA39_DIALOG_RequireGameDiskInDrive_NoDialogDrawn</code> is called which will in turn calls <code>F452_xxxx_FLOPPY_GetDiskTypeInDrive_COPYPROTECTIONB</code> and triggers COPYPROTECTIONB and displays a dialog box with the message "THAT'S NOT THE MASTER DISK!"</p>
<p>There must not be any other floppy disk activity while a copy protected sector is being read with the custom subroutines (including another copy protection sector read). The game functions that need to access the floppy disk while being in game wait until the read operation is complete (until <code>G625_i_FloppyDriveDMATimeout_COPYPROTECTIONDF = 0</code>) before proceeding. Here is the list of these functions:</p>
<ul><li><code>F096_qzzz_DUNGEONVIEW_LoadCurrentMapGraphics_COPYPROTECTIONDF</code></li>
<li><code>F118_xxxx_DUNGEONVIEW_DrawSquareD3C_COPYPROTECTIONF</code> (before installing graphic #538)</li>
<li><code>F433_AA39_STARTEND_ProcessCommand140_SaveGame_COPYPROTECTIONCDF</code> (this one has its own custom builtin routines to read sector 7)</li>
<li><code>S465_qzzz_COPYPROTECTIOND_ReadSector247</code></li>
<li><code>F474_xxxx_MEMORY_LoadGraphic_COPYPROTECTIONDF</code></li>
<li><code>F477_izzz_MEMORY_OpenGraphicsDat_COPYPROTECTIONDF</code></li>
<li><code>F478_gzzz_MEMORY_CloseGraphicsDat_COPYPROTECTIONDF</code></li>
<li><code>F484_gzzz_MEMORY_LoadGraphics_COPYPROTECTIONDEF</code></li></ul>
<p>Some functions also wait until <code>G625_i_FloppyDriveDMATimeout_COPYPROTECTIONDF = 0</code> not because they need to access the floppy disk but rather in order to make sure the last copy protection read operation has completed:</p>
<ul><li><code>F106_rzzz_DUNGEONVIEW_TestResetToStep1_COPYPROTECTIONF</code></li>
<li><code>F120_xxxx_DUNGEONVIEW_DrawSquareD2R_COPYPROTECTIONF</code></li></ul>
<h2><a name="COPYPROTECTIONA">Copy protection A</a></h2>
<p>Keywords in source code: COPYPROTECTIONA, COPYPROTECTIONADEF</p>
<p>COPYPROTECTIONA checks that the main program was started with a specific command line parameter. This check is performed only once when the program starts.<br/>
When you boot the computer using the game disk, the boot sector is executed. It loads and runs <code>SWOOSH.IMG</code> which in turn runs <code>START.PRG</code> with the command line parameter <code>AUTO</code>. <code>START.PRG</code> decompresses the main program stored in <code>START.PAK</code> in memory and runs it using the same command line parameter (it is not specified again, it simply reuses the same command line in place). Note that if you run a <code>.PRG</code> file manually from the desktop, the operating system does not ask for command line parameters (like it does for <code>.TTP</code> executables).<br/>
The first function that is called by <code>main()</code> is either <code>F448_xxxx_MEMINIT_InitializeMemoryManager_COPYPROTECTIONADEF</code> (in Dungeon Master) or <code>F463_wzzz_START_InitializeGame_COPYPROTECTIONADEF</code> (in Chaos Strikes Back). These functions check that the first four characters of the command line used to run the program are <code>AUTO</code> and then call <code>F447_xxxx_STARTEND_HangIfFalse_COPYPROTECTIONA</code>. If the command line is not the expected one then this function hangs the game with an infinite loop.</p>
<h2><a name="COPYPROTECTIONB">Copy protection B</a></h2>
<p>Keywords in source code: COPYPROTECTIONB</p>
<p>COPYPROTECTIONC checks that sector 10 can be read (there are only 9 sectors on standard Atari ST floppy disks) and that the copy protection sector 247 can be read and contains two specific strings at expected locations.<br/>
This check is performed each time the game requires the game disk in the drive. If the disk is a copy and one of these sectors cannot be read then the game detects the floppy disk as a save game disk.<br/>
When the game requires the game disk in the drive, which occurs for example when you start a new game or resume a saved game in order to load graphics or the dungeon, it calls <code>F452_xxxx_FLOPPY_GetDiskTypeInDrive_COPYPROTECTIONB</code> to determine which type of disk is currently in the drive. In order to detect the game disk, this function calls the XBIOS function <code>Floprd()</code> twice to read sector 10 and sector 247 from track 0 into a temporarily allocated memory buffer. Standard Atari ST floppies only have 9 sectors per track, numbered from 1 to 9. The original game disk has 10 sectors per track, number from 1 to 10 except for sector 8 which is replaced by sector 247. If both sector 7 and sector 247 could be read, the function also checks that the strings "Copyright (c) 1987, Software Heaven, Inc." and "DungeonMaster" are at the expected locations in sector 247. If any call to <code>Floprd()</code> fails or if the strings are not found where expected, then the game disk is not detected. This causes the game to permanently display a dialog box with the message "THAT'S NOT THE MASTER DISK!".</p>
<h2><a name="COPYPROTECTIONC">Copy protection C</a></h2>
<p>Keywords in source code: COPYPROTECTIONC, COPYPROTECTIONCE, COPYPROTECTIONCDF</p>
<p>COPYPROTECTIONC checks that the copy protection sector 7 can be read and that it contains at least one fuzzy bit.<br/>
This check is performed each time the player saves the game. Any change made to this function (in order to crack the copy protection) is detected by 3 other functions in the game that compute checksums of the code of the save game function. These three checksums are computed using 3 different algorithms so that it is virtually impossible to change the function in a way that would both crack the copy protection and not change at least one of the 3 checksum values. Moreover, one of the 3 functions that compute the checksums is also protected againt changes with another checksum computed on its own code.</p>
<p>When saving the game, <code>F433_AA39_STARTEND_ProcessCommand140_SaveGame_COPYPROTECTIONCDF</code> contains inline assembly code to read sector 7 in a temporarily allocated buffer and check the fuzzy bits values. These operations are performed twice in a row. The game displays a dialog box with the message "THAT'S NOT THE MASTER DISK!" until at least one fuzzy bit is detected between the two sector readings.<br/>
In Dungeon Master, the sector is read by calling <code>Floprd()</code>. In Chaos Strikes Back, the sector is read using custom code similar to the code in graphic #538, in <code>S080_aaat_COPYPROTECTIONDF_CheckDMATransferCompletion</code> and in <code>S081_aaao_COPYPROTECTIONDF_TurnOffFloppyDrive</code>.</p>
<p>The first time a dungeon is loaded after the game has loaded (hence not when restarting a game after the party died) <code>F434_xxxx_STARTEND_IsLoadDungeonSuccessful_COPYPROTECTIONC</code> has to allocate memory for the dungeon map data in <code>G279_pppuc_DungeonMapData</code>. <code>F079_a002_COPYPROTECTIONC_GetChecksumAdd</code> is called to check that the function <code>F433_AA39_STARTEND_ProcessCommand140_SaveGame_COPYPROTECTIONCDF</code> has not been modified. If the function was modified then memory is not allocated and <code>G279_pppuc_DungeonMapData</code> is not initialized correctly. This will crash the game.</p>
<p>When the player opens the save game menu by pressing CTRL-S on the keyboard or by clicking on the disk icon in the champion inventory, the command <code>C140_COMMAND_SAVE_GAME</code> is issued. When processing that command in <code>F380_xzzz_COMMAND_ProcessQueue_COPYPROTECTIONC</code>, <code>F464_AA07_COPYPROTECTIONC_GetChecksumSub</code> is called to check that the function <code>F433_AA39_STARTEND_ProcessCommand140_SaveGame_COPYPROTECTIONCDF</code> has not been modified. If the function was modified then the champion inventory is closed instead of displaying the save game menu.</p>
<p>When <code>F267_dzzz_MOVE_GetMoveResult_COPYPROTECTIONCE</code> is called to move the party or an object to a destination where MapIndex &gt; 2 and MapX is a multiple of 8 and MapY is a multiple of 4 then it calls <code>F413_AA08_COPYPROTECTIONC_GetChecksumEor</code> to check that the function <code>F433_AA39_STARTEND_ProcessCommand140_SaveGame_COPYPROTECTIONCDF</code> has not been modified. If the function was modified then the destination coordinates are altered so that the party or object may move to an invalid location. This will crash the game.</p>
<p>When the player clicks a mouse button while the command queue is locked, <code>F359_hzzz_COMMAND_ProcessClick_COPYPROTECTIONC</code> buffers the click and if <code>G440_B_Consequence_StopSearchingMouseInput_COPYPROTECTIONC = FALSE</code> it calls <code>F464_AA07_COPYPROTECTIONC_GetChecksumSub</code> to check that the function <code>F380_xzzz_COMMAND_ProcessQueue_COPYPROTECTIONC</code> had not been modified. If the function was modified then <code>G440_B_Consequence_StopSearchingMouseInput_COPYPROTECTIONC</code> is incremented (equivalent as setting it to <code>TRUE</code>) which causes <code>F358_xxxx_COMMAND_GetCommandFromMouseInput_COPYPROTECTIONC</code> to stop searching in mouse input lists, thus ignoring mouse clicks indefinitely.</p>
<h2><a name="COPYPROTECTIOND">Copy protection D</a></h2>
<p>Keywords in source code: COPYPROTECTIOND, COPYPROTECTIONADEF, COPYPROTECTIONCDF, COPYPROTECTIONDF, COPYPROTECTIONDEF</p>
<p>COPYPROTECTIOND checks that the copy protection sector 247 can be read. No check is made on the actual contents of this sector.<br/>
It is spread over 3 functions and can be in two distinct states. The current state of COPYPROTECTIOND is stored in <code>G240_i_Graphic559_State_COPYPROTECTIOND</code>.</p>
<h3>State 1: the value of <code>G240_i_Graphic559_State_COPYPROTECTIOND</code> is even</h3>
<p>The next step to execute is 'Read sector 247'. COPYPROTECTIOND starts with this step because <code>G240_i_Graphic559_State_COPYPROTECTIOND</code> is set to 4 (even) when the game starts running (as loaded from graphic #559).</p>
<p>Each time <code>F064_aadz_SOUND_RequestPlay_COPYPROTECTIOND</code> is called to play a sound immediately (when the party movement is blocked, when a champion swallows, when a teleporter buzzes and when the party screams because of death or a fall through a pit), <code>G586_i_ImmediateSoundCount_COPYPROTECTIOND</code> is incremented. When <code>G586_i_ImmediateSoundCount_COPYPROTECTIOND &gt;= 88</code> and there is no copy protection sector being read (<code>G625_i_FloppyDriveDMATimeout_COPYPROTECTIONDF = 0</code>) then</p>
<ul><li><code>G586_i_ImmediateSoundCount_COPYPROTECTIOND</code> is reset to 0.</li>
<li>The value of <code>G240_i_Graphic559_State_COPYPROTECTIOND</code> is changed so it becomes odd (+3). This moves COPYPROTECTIOND to State 2.</li>
<li>A flag is set in <code>G644_i_FloppyDiskReadBufferContentType_COPYPROTECTIONDF</code> to indicate that the buffer contains sector 247.</li>
<li><code>S465_qzzz_COPYPROTECTIOND_ReadSector247</code> is called to read sector 247 in the last 512 bytes of <code>G643_puc_FloppyDiskReadBuffer_COPYPROTECTIONDF</code>.</li>
<li>The values of <code>G329_i_Useless_COPYPROTECTIOND</code> and <code>G058_i_Graphic562_Useless_COPYPROTECTIOND</code> are also updated but these variables are never used anywhere else in the program.</li></ul>
<h3>State 2: the value of <code>G240_i_Graphic559_State_COPYPROTECTIOND</code> is odd</h3>
<p>Sector 247 was read and the next step to execute is 'Apply consequence and Reset COPYPROTECTIOND to step 1' (there is no consequence if the read operation succeeded).</p>
<ul><li>Apply consequence:
<ul><li>In <code>F002_xxxx_MAIN_GameLoop_COPYPROTECTIONDF</code>, every 64 ticks, if there is a copy protection sector read failure (flag set in <code>G315_i_SectorsReadFailure_COPYPROTECTIONDF</code>) and the previous read succeeded (flag not set in <code>G316_i_SectorsReadPreviousFailure_COPYPROTECTIONDF</code>) then the program requires the game disk in the drive. This triggers COPYPROTECTIONB and displays a dialog box with the message "THAT'S NOT THE MASTER DISK!"</li></ul></li>
<li>Reset COPYPROTECTIOND to step 1 (this cannot occur before 'Apply consequence'):
<ul><li>When <code>F065_aanz_SOUND_PlayPendingSound_COPYPROTECTIOND</code> is called by <code>main()</code>, if <code>G240_i_Graphic559_State_COPYPROTECTIOND</code> is odd and there is no copy protection sector being read (<code>G625_i_FloppyDriveDMATimeout_COPYPROTECTIONDF = 0</code>) then
<ul><li>if the previous reading of sector 247 was a failure (in <code>G316_i_SectorsReadPreviousFailure_COPYPROTECTIONDF</code>, which means <code>F002_xxxx_MAIN_GameLoop_COPYPROTECTIONDF</code> has already displayed the dialog after a read failure and copied <code>G315_i_SectorsReadFailure_COPYPROTECTIONDF</code> into <code>G316_i_SectorsReadPreviousFailure_COPYPROTECTIONDF</code>) then clear the failure bits for sector 247 in <code>G316_i_SectorsReadPreviousFailure_COPYPROTECTIONDF</code> and <code>G315_i_SectorsReadFailure_COPYPROTECTIONDF</code>. This resets the status for the next pass of COPYPROTECTIOND.</li>
<li><code>G240_i_Graphic559_State_COPYPROTECTIOND</code> is incremented so the value becomes even. This moves COPYPROTECTIOND back to State 1.</li></ul></li></ul></li></ul>
<p>Note: <code>G240_i_Graphic559_State_COPYPROTECTIOND</code> is also changed (+4) in <code>F210_uzzz_COPYPROTECTIONE_ProcessEvent22_IsSector7Valid_NormalBytes</code>. If the value was odd it remains odd and if it was even it remains even. Because the effect of this variable is not based directly on its value but only on its oddness, this change of value actually has no effect.</p>
<h2><a name="COPYPROTECTIONE">Copy protection E</a></h2>
<p>Keywords in source code: COPYPROTECTIONE, COPYPROTECTIONADEF, COPYPROTECTIONCE, COPYPROTECTIONDEF, COPYPROTECTIONEF</p>
<p>When the game is initialized <code>Floprd()</code> is called to read sector 7 into <code>G295_ac_Sector7ReadingBuffer_COPYPROTECTIONE</code> in <code>F448_xxxx_MEMINIT_InitializeMemoryManager_COPYPROTECTIONADEF</code> (DM) or <code>F463_wzzz_START_InitializeGame_COPYPROTECTIONADEF</code> (CSB).</p>
<p>Each time the party moves to a different map <code>F003_aaaS_MAIN_ProcessNewPartyMap_COPYPROTECTIONE</code> is called. It calls <code>F096_qzzz_DUNGEONVIEW_LoadCurrentMapGraphics_COPYPROTECTIONDF</code> which calls <code>F484_gzzz_MEMORY_LoadGraphics_COPYPROTECTIONDEF</code> which in turn calls <code>Floprd()</code> to read sector 7 into <code>G295_ac_Sector7ReadingBuffer_COPYPROTECTIONE</code>.<br/>
If <code>G418_l_LastEvent22Time_COPYPROTECTIONE</code> is more than 500 ticks in the past (this prevents checking the copy protection on each map change if the player changes multiple times over a short period of time) then:</p>
<ul><li>Add an event 22 to the timeline expiring 2 (DM) or 3 (CSB) ticks in the future.
<ul><li>Upon expiration, <code>F261_hzzz_TIMELINE_Process_COPYPROTECTIONEF</code> calls <code>F210_uzzz_COPYPROTECTIONE_ProcessEvent22_IsSector7Valid_NormalBytes</code>.</li>
<li>If this test fails then set <code>G022_i_Graphic562_IndirectStopExpiringEvent_COPYPROTECTIONE = C00136_TRUE</code>. This causes an incrementation of <code>G330_i_StopExpiringEvents_COPYPROTECTIONE</code> in <code>F267_dzzz_MOVE_GetMoveResult_COPYPROTECTIONCE</code> (<code>G022_i_Graphic562_IndirectStopExpiringEvent_COPYPROTECTIONE</code> is also reset to <code>C00555_FALSE</code>).</li></ul></li>
<li>Read sector 7 in <code>G295_ac_Sector7ReadingBuffer_COPYPROTECTIONE</code> with <code>Floprd()</code></li>
<li>Set <code>G488_i_Graphic560_RequestCheckFuzzyBitCount_COPYPROTECTIONE = C01113_TRUE</code> in order to trigger a call to <code>F356_ozzz_COPYPROTECTIONE_IsSector7Valid_ByteValuesAndFuzzyBitCount</code> in the next call to <code>F077_aA39_MOUSE_HidePointer_COPYPROTECTIONE</code>
<ul><li><code>F356_ozzz_COPYPROTECTIONE_IsSector7Valid_ByteValuesAndFuzzyBitCount</code> resets <code>G488_i_Graphic560_RequestCheckFuzzyBitCount_COPYPROTECTIONE</code>. This function stores its results in two static local variables <code>G628_i_LastFuzzyBitCount_COPYPROTECTIONE</code> and <code>G629_i_ConsecutiveIdenticalFuzzyBitCounts_COPYPROTECTIONE</code> for comparison during the next call.</li>
<li>If the test fails, set <code>G189_i_Graphic558_StopAddingEvents_COPYPROTECTIONE = C01113_TRUE</code></li></ul></li>
<li>Set <code>G031_i_Graphic562_Sector7Analyzed_COPYPROTECTIONE = C00255_FALSE</code> in order to trigger either:
<ul><li>A call to <code>F277_jzzz_COPYPROTECTIONE_IsSector7Valid_FuzzyBits</code> in the next call to either
<ul><li><code>F369_xxxx_COMMAND_ProcessTypes101To108_ClickInSpellSymbolsArea_COPYPROTECTIONE</code> when the player casts a spell</li>
<li><code>F371_xxxx_COMMAND_ProcessType111To115_ClickInActionArea_COPYPROTECTIONE</code> when the player performs the second action in the list</li>
<li><code>F115_xxxx_DUNGEONVIEW_DrawObjectsCreaturesProjectilesExplosions_COPYPROTECTIONEF</code> when drawing an explosion on the party square</li></ul>
During this call <code>F277_jzzz_COPYPROTECTIONE_IsSector7Valid_FuzzyBits</code> will:
<ul><li>reset <code>G031_i_Graphic562_Sector7Analyzed_COPYPROTECTIONE</code> to <code>C00136_TRUE</code>.</li>
<li>reset <code>G068_i_CheckLastEvent22Time_COPYPROTECTIONE</code> to <code>C00512_FALSE</code></li></ul>
If the test fails in any of the three functions, set <code>G189_i_Graphic558_StopAddingEvents_COPYPROTECTIONE = C00136_TRUE</code></li>
<li>In <code>F338_atzz_INVENTORY_DecreaseTorchesLightPower_COPYPROTECTIONE</code>, if <code>G031_i_Graphic562_Sector7Analyzed_COPYPROTECTIONE != C00136_TRUE</code>:
<ul><li>Calls <code>F137_pzzz_COPYPROTECTIONEF_PatchFunctionWithHiddenCodeLauncher</code> to patch <code>F331_auzz_CHAMPION_ApplyTimeEffects_COPYPROTECTIONF</code> with a copy of <code>R138_lzzz_COPYPROTECTIONEF_HiddenCodeLauncher</code> copied to a randomly selected buffer from the list in <code>G368_apc_CodePatches_COPYPROTECTIONE</code> which contains 6 buffers: <code>G585_ac_CodePatch0_COPYPROTECTIONE</code>, <code>G344_ac_CodePatch1_COPYPROTECTIONE</code>, <code>G533_ac_CodePatch2_COPYPROTECTIONE</code>, <code>G408_ac_CodePatch3_COPYPROTECTIONE</code>, <code>G393_ac_CodePatch4_COPYPROTECTIONE</code>, <code>G427_ac_CodePatch5_COPYPROTECTIONE</code>. The patch routine is configured to run hidden code from graphic #21 (<code>C021_GRAPHIC_CHECK_FUZZY_BITS_SECTOR_7</code>) with the address of <code>G429_apc_Graphic21Result_COPYPROTECTIONE</code> specified as parameter. This array contains 3 (DM) or 4 (CSB) pointers to the following variables:
<ul><li><code>int G293_ai_FuzzyBits_COPYPROTECTIONE[32]</code> graphic #21 compares fuzzy bits from sector 7 with the ones here (from previous reading) and then replaces them here</li>
<li><code>int G031_i_Graphic562_Sector7Analyzed_COPYPROTECTIONE</code></li>
<li><code>long G418_l_LastEvent22Time_COPYPROTECTIONE</code></li>
<li><code>int G068_i_CheckLastEvent22Time_COPYPROTECTIONE</code> (Chaos Strikes Back only)</li></ul></li>
<li>When the patched function is executed (just a bit after <code>F338_atzz_INVENTORY_DecreaseTorchesLightPower_COPYPROTECTIONE</code> in <code>F002_xxxx_MAIN_GameLoop_COPYPROTECTIONDF</code>), the hidden code is executed first and then the function is restored to its original form without the patch. The hidden code in graphic #21 will collect all fuzzy bits from the sector 7 stored into <code>G295_ac_Sector7ReadingBuffer_COPYPROTECTIONE</code> and store them in <code>G293_ai_FuzzyBits_COPYPROTECTIONE</code>. It will then set <code>G031_i_Graphic562_Sector7Analyzed_COPYPROTECTIONE</code> to <code>C00136_TRUE</code>. If at least one fuzzy bit was detected then <code>G418_l_LastEvent22Time_COPYPROTECTIONE</code> is not affected else it is set to 0. In CSB, <code>G068_i_CheckLastEvent22Time_COPYPROTECTIONE</code> is set to <code>C00512_FALSE</code></li></ul></li></ul></li>
<li>CSB only: Set <code>G068_i_CheckLastEvent22Time_COPYPROTECTIONE = C00555_TRUE</code> in order to trigger a check in <code>F355_hzzz_INVENTORY_Toggle_COPYPROTECTIONE</code> that the last event 22 occured less than 1000 ticks ago. <code>G068_i_CheckLastEvent22Time_COPYPROTECTIONE</code> is reset by graphic #21 if it runs or by <code>F277_jzzz_COPYPROTECTIONE_IsSector7Valid_FuzzyBits</code>.
<ul><li>If this test fails then <code>G330_i_StopExpiringEvents_COPYPROTECTIONE</code>++</li></ul></li></ul>
<h3>Consequences</h3>
<p>In <code>F240_xxxx_TIMELINE_IsFirstEventExpired_COPYPROTECTIONE</code>, if <code>G330_i_StopExpiringEvents_COPYPROTECTIONE &gt;= 2</code> then events do not expire anymore.</p>
<p>In <code>F238_pzzz_TIMELINE_AddEvent_GetEventIndex_COPYPROTECTIONE</code></p>
<ul><li>If <code>G189_i_Graphic558_StopAddingEvents_COPYPROTECTIONE</code> was changed from its initial value of 3217 then the event is not added to the timeline.</li>
<li>In CSB, the same happens also if <code>G418_l_LastEvent22Time_COPYPROTECTIONE = 0</code></li></ul>
<h2><a name="COPYPROTECTIONF">Copy protection F</a></h2>
<p>Keywords in source code: COPYPROTECTIONF, COPYPROTECTIONADEF, COPYPROTECTIONCDF, COPYPROTECTIONDF, COPYPROTECTIONDEF, COPYPROTECTIONEF</p>
<p>COPYPROTECTIONF checks that the copy protection sector 7 can be read and that it contains at least one fuzzy bit. These operations are performed by executing 2 pieces of code hidden in <code>GRAPHICS.DAT</code> as regular bitmaps.<br/>
It is spread over many functions and can be in 7 distinct states. The current state of COPYPROTECTIONF is stored in <code>G069_ui_State_COPYPROTECTIONF</code>. If the floppy disk is original, then the value of <code>G069_ui_State_COPYPROTECTIONF</code> will follow a sequence of 7 values corresponding to the 7 states: 15 5 10 16 6 11 13. This sequence will cause two cycles of read and analyze of sector 7, and finally COPYPROTECTIONF will stop until the game is booted again. In version 1.1 and above, COPYPROTECTIONF is also reset to step 1 when the game is restarted (when loading a game after the party has died) because <code>F462_xxxx_START_StartGame_COPYPROTECTIONF</code> reinitializes these values:</p>
<ul><li><code>G069_ui_State_COPYPROTECTIONF = 15</code></li>
<li><code>G070_B_Sector7Analyzed_COPYPROTECTIONF = FALSE</code></li>
<li><code>G071_B_Sector7ReadingInitiated_COPYPROTECTIONF = FALSE</code></li></ul>
<p>COPYPROTECTIONF is interwoven with the functions responsible for drawing the dungeon view. The full cycle of 7 states may occur over many executions of these functions as it depends on what is visible in the dungeon view (square types, projectiles).</p>
<p><code>F435_xxxx_STARTEND_LoadGame_COPYPROTECTIONF</code> sets <code>G319_ul_LoadGameTime_COPYPROTECTIONF</code> to the game time value from the saved game file.</p>
<h3>State 1: <code>G069_ui_State_COPYPROTECTIONF = 15</code>: 'First sector 7 reading'</h3>
<p>This is the initial state. In versions 1.0, it is set only when the game is loaded. In version 1.1 and above, it is set each time a game is started (when the player starts a new game or restarts from a saved game).</p>
<p>In this state <code>F118_xxxx_DUNGEONVIEW_DrawSquareD3C_COPYPROTECTIONF</code> will perform the following actions if square D3C is a visible teleporter and <code>G069_ui_State_COPYPROTECTIONF &gt;= 15</code> and there is no ongoing copy protected sector reading and the player either (loaded the current game before 66531 ticks of total play time (<code>G319_ul_LoadGameTime_COPYPROTECTIONF &lt; 66531</code>) and more than 65530 ticks of total play time have now passed (<code>G313_ul_GameTime &gt; 65530</code>)) or (played for at least 8192 ticks since the game was loaded (<code>G313_ul_GameTime &gt; G319_ul_LoadGameTime_COPYPROTECTIONF + 8192</code>)):</p>
<ul><li>Call <code>F137_pzzz_COPYPROTECTIONEF_PatchFunctionWithHiddenCodeLauncher</code> to patch one of the 4 functions (randomly selected):
<ul><li><code>F123_xxxx_DUNGEONVIEW_DrawSquareD1R</code></li>
<li><code>F124_xxxx_DUNGEONVIEW_DrawSquareD1C</code></li>
<li><code>F122_xxxx_DUNGEONVIEW_DrawSquareD1L</code></li>
<li><code>F126_xxxx_DUNGEONVIEW_DrawSquareD0R</code></li></ul>
with a copy of <code>R138_lzzz_COPYPROTECTIONEF_HiddenCodeLauncher</code> copied to a randomly selected buffer from the list in <code>G104_apc_CodePatches_COPYPROTECTIONF</code> which contains 3 buffers: <code>G082_ac_CodePatch0_COPYPROTECTIONF</code>, <code>G089_ac_CodePatch1_COPYPROTECTIONF</code>, <code>G100_ac_CodePatch2_COPYPROTECTIONF</code>. The patch routine is configured to run hidden code from graphic #538 (<code>C538_GRAPHIC_READ_SECTOR_7</code>) with the address of <code>G625_i_FloppyDriveDMATimeout_COPYPROTECTIONDF</code> specified as parameter so that graphic #538 can set the values of both <code>G624_B_FloppyDriveTurnedOn_COPYPROTECTIONDF</code> to <code>TRUE</code> and <code>G625_i_FloppyDriveDMATimeout_COPYPROTECTIONDF</code> to 259. When the patched function is executed (just a bit later in the process of drawing the dungeon view in <code>F128_rzzz_DUNGEONVIEW_Draw_COPYPROTECTIONF</code>), the hidden code is executed first and then the function is restored to its original form without the patch. The hidden code in graphic #538 will initiate a read operation of sector 7 into <code>G643_puc_FloppyDiskReadBuffer_COPYPROTECTIONDF</code>.</li>
<li><code>G069_ui_State_COPYPROTECTIONF</code> is decreased by 10: if the value was 15 it is now 5 (State 2), if the value was 16 it is now 6 (State 5).</li>
<li><code>G071_B_Sector7ReadingInitiated_COPYPROTECTIONF = FALSE</code></li></ul>
<p>At the end of <code>F128_rzzz_DUNGEONVIEW_Draw_COPYPROTECTIONF</code> after all functions that draw squares have been called, <code>G071_B_Sector7ReadingInitiated_COPYPROTECTIONF</code> is set to <code>TRUE</code></p>
<h3>State 2: <code>G069_ui_State_COPYPROTECTIONF = 5</code>: 'Analyze first sector 7 reading'</h3>
<p>In this state <code>F120_xxxx_DUNGEONVIEW_DrawSquareD2R_COPYPROTECTIONF</code> will perform the following actions if square D2R looks like a wall (without an alcove ornament) and <code>G069_ui_State_COPYPROTECTIONF &lt;= 6</code> and <code>G071_B_Sector7ReadingInitiated_COPYPROTECTIONF = TRUE</code> and there is no copy protected sector being read (<code>G625_i_FloppyDriveDMATimeout_COPYPROTECTIONDF = 0</code>), that is, if the sector 7 reading operation has completed:</p>
<ul><li>If sector 7 reading failed or if <code>G644_i_FloppyDiskReadBufferContentType_COPYPROTECTIONDF</code> does not contain sector 7 then
<ul><li>If there have been two consecutive sector 7 read failures then <code>G072_ui_GraceReadRetryCount_COPYPROTECTIONF++</code></li>
<li>If the previous sector 7 reading failed then add 10 to <code>G069_ui_State_COPYPROTECTIONF</code>, which causes COPYPROTECTIONF to go back to the previous state to read sector 7 again: if current state is State 2 then <code>G069_ui_State_COPYPROTECTIONF</code> is set to 15 (State 1), if current state is State 5 then <code>G069_ui_State_COPYPROTECTIONF</code> is set to 16 (State 4)</li></ul>
</li><li>else
<ul><li>Set <code>G070_B_Sector7Analyzed_COPYPROTECTIONF = FALSE</code>. In Chaos Strikes Back only, set <code>G073_i_StopFreeingMemory_COPYPROTECTIONF = C00555_TRUE</code>. These values will be overwritten when executing graphic #21 below.</li>
<li>Calls <code>F137_pzzz_COPYPROTECTIONEF_PatchFunctionWithHiddenCodeLauncher</code> to patch one of the 2 functions (randomly selected)
<ul><li><code>F124_xxxx_DUNGEONVIEW_DrawSquareD1C</code></li>
<li><code>F125_xxxx_DUNGEONVIEW_DrawSquareD0L</code></li></ul>
with a copy of <code>R138_lzzz_COPYPROTECTIONEF_HiddenCodeLauncher</code> copied to a randomly selected buffer from the list in <code>G104_apc_CodePatches_COPYPROTECTIONF</code> which contains 3 buffers: <code>G082_ac_CodePatch0_COPYPROTECTIONF</code>, <code>G089_ac_CodePatch1_COPYPROTECTIONF</code>, <code>G100_ac_CodePatch2_COPYPROTECTIONF</code>. The patch routine is configured to run hidden code from graphic #21 (<code>C021_GRAPHIC_CHECK_FUZZY_BITS_SECTOR_7</code>) with the address of <code>G083_apc_Graphic21Result_COPYPROTECTIONF</code> specified as parameter. This array contains 4 pointers to the following variables:
<ul><li><code>int G081_ai_FuzzyBits_COPYPROTECTIONF[32]</code> graphic #21 compares fuzzy bits from sector 7 with the ones here (from previous reading) and then replaces them here</li>
<li><code>BOOLEAN G070_B_Sector7Analyzed_COPYPROTECTIONF</code></li>
<li><code>BOOLEAN G078_B_FuzzyBitFound_COPYPROTECTIONF</code></li>
<li><code>BOOLEAN G071_B_Sector7ReadingInitiated_COPYPROTECTIONF</code> (Dungeon Master only, not used)<br/>
<code>int G073_i_StopFreeingMemory_COPYPROTECTIONF</code> (Chaos Strikes Back only)</li></ul></li>
<li>When the patched function is executed (just a bit later in the process of drawing the dungeon view in <code>F128_rzzz_DUNGEONVIEW_Draw_COPYPROTECTIONF</code>), the hidden code is executed first and then the function is restored to its original form without the patch. The hidden code in graphic #21 will collect all fuzzy bits from the sector 7 stored into <code>G643_puc_FloppyDiskReadBuffer_COPYPROTECTIONDF</code> and store them in <code>G081_ai_FuzzyBits_COPYPROTECTIONF</code>. It will then set <code>G070_B_Sector7Analyzed_COPYPROTECTIONF</code> to <code>C00136_TRUE</code>. If at least one fuzzy bit was detected then <code>G078_B_FuzzyBitFound_COPYPROTECTIONF</code> is not affected else it is set to 0.</li>
<li>BUG0_01 Coding error without consequence. If graphic #21 is called with G643_puc_FloppyDiskReadBuffer_COPYPROTECTIONDF as second parameter and it does not detect any fuzzy bit then it writes 0 as a long (4 bytes) to <code>G078_B_FuzzyBitFound_COPYPROTECTIONF</code> but this variable is an int (2 bytes) which causes <code>G077_B_DoNotDrawFluxcagesDuringEndgame</code> (not related to the copy protection) to be overwritten too as a side effect as it is the next variable in memory. No consequence because the value of this variable is always 0 until the very end of the game.</li>
<li>In Dungeon Master the fourth pointer to <code>G071_B_Sector7ReadingInitiated_COPYPROTECTIONF</code> is not used by graphic #21. In Chaos Strikes Back, this fourth pointer is replaced by <code>G073_i_StopFreeingMemory_COPYPROTECTIONF</code> and graphic #21 sets this value to <code>C00512_FALSE</code>.</li>
<li>Add 5 to <code>G069_ui_State_COPYPROTECTIONF</code>, which causes COPYPROTECTIONF to proceed to the next state: if current state is State 2 then <code>G069_ui_State_COPYPROTECTIONF</code> is set to 10 (State 3), if current state is State 5 then <code>G069_ui_State_COPYPROTECTIONF</code> is set to 11 (State 6)</li></ul></li></ul>
<h3>State 3: <code>G069_ui_State_COPYPROTECTIONF = 10</code>: 'Proceed to second reading'</h3>
<p>In <code>F115_xxxx_DUNGEONVIEW_DrawObjectsCreaturesProjectilesExplosions_COPYPROTECTIONEF</code>, if <code>G070_B_Sector7Analyzed_COPYPROTECTIONF</code> then the value of <code>G069_ui_State_COPYPROTECTIONF</code> is adjusted: if current state is State 3 then <code>G069_ui_State_COPYPROTECTIONF</code> is set to 16 (State 4), if current state is State 6 then <code>G069_ui_State_COPYPROTECTIONF</code> is set to 13 (State 7)</p>
<h3>State 4: <code>G069_ui_State_COPYPROTECTIONF = 16</code>: 'Second sector 7 reading'</h3>
<p>In this state, COPYPROTECTIONF has the same behavior as state 1, but for a second cycle.</p>
<h3>State 5: <code>G069_ui_State_COPYPROTECTIONF = 6</code>: 'Analyze second sector 7 reading'</h3>
<p>In this state, COPYPROTECTIONF has the same behavior as state 2, but for a second cycle.</p>
<h3>State 6: <code>G069_ui_State_COPYPROTECTIONF = 11</code>: ''</h3>
<p>In this state, COPYPROTECTIONF has the same behavior as state 3, but for a second cycle.</p>
<h3>State 7: <code>G069_ui_State_COPYPROTECTIONF = 13</code>: 'End of COPYPROTECTIONF'</h3>
<p>In this state, nothing happens anymore with COPYPROTECTIONF. In version 1.1 and above, COPYPROTECTIONF is reset to state 1 when restarting the game after the party has died.</p>
<h3>Consequences of COPYPROTECTIONF</h3>
<p>In <code>F107_xxxx_DUNGEONVIEW_IsDrawnWallOrnamentAnAlcove_COPYPROTECTIONF</code></p>
<ul><li>Calls <code>F106_rzzz_DUNGEONVIEW_TestResetToStep1_COPYPROTECTIONF</code>.
<ul><li>If the number of retries in <code>G072_ui_GraceReadRetryCount_COPYPROTECTIONF &lt; 5</code> and no fuzzy bit was found in the last sector 7 reading (<code>G078_B_FuzzyBitFound_COPYPROTECTIONF = FALSE</code>) then
<ul><li>If no copy protected sector is being read and sector 7 was read without failure then set failure flag in <code>G315_i_SectorsReadFailure_COPYPROTECTIONDF</code> because no fuzzy bit was found and increment <code>G072_ui_GraceReadRetryCount_COPYPROTECTIONF</code>.</li>
<li>Reset COPYPROTECTIONF to state 1 by setting <code>G069_ui_State_COPYPROTECTIONF</code> to 15</li></ul></li></ul></li>
<li>If no fuzzy bit was found in the last sector 7 reading (<code>G078_B_FuzzyBitFound_COPYPROTECTIONF = FALSE</code>) then Altars of Vi cannot be used anymore.</li></ul>
<p>In <code>F128_rzzz_DUNGEONVIEW_Draw_COPYPROTECTIONF</code></p>
<ul><li>In Chaos Strikes Back only, if sector 7 reading was not initiated by graphic #538 yet (<code>G071_B_Sector7ReadingInitiated_COPYPROTECTIONF = FALSE</code>) and (<code>G073_i_StopFreeingMemory_COPYPROTECTIONF != C00512_FALSE</code>) (the value of <code>G073_i_StopFreeingMemory_COPYPROTECTIONF</code> is set to <code>C00512_FALSE</code> by graphic #21) then do nothing (This will eventually cause the game to run out of memory) else
<ul><li><code>G071_B_Sector7ReadingInitiated_COPYPROTECTIONF = TRUE</code>. At this step the function patched with graphic #21 has necessarily been executed, but the sector reading may still be in progress.</li>
<li>Free the temporary memory allocated for drawing the dungeon view.</li></ul></li></ul>
<p>In <code>E017_xxxx_MAIN_Exception28Handler_VerticalBlank_COPYPROTECTIONDF</code></p>
<ul><li>If no fuzzy bit was found (<code>G078_B_FuzzyBitFound_COPYPROTECTIONF = FALSE</code>) then
<ul><li>if <code>G328_i_TimeBombToKillParty_COPYPROTECTIONF</code> = 0 then
<ul><li>Call <code>F106_rzzz_DUNGEONVIEW_TestResetToStep1_COPYPROTECTIONF</code></li>
<li><code>G328_i_TimeBombToKillParty_COPYPROTECTIONF += 5</code>.</li></ul></li></ul></li></ul>
<p>In <code>F331_auzz_CHAMPION_ApplyTimeEffects_COPYPROTECTIONF</code></p>
<ul><li>if <code>G328_i_TimeBombToKillParty_COPYPROTECTIONF</code> is not 0 then it is decremented and when reaching 1
<ul><li><code>G524_B_RestartGameAllowed</code> is set to <code>FALSE</code> and the whole party is killed, without the ability to restart from a saved game. Rebooting from scratch is necessary.</li>
<li><code>G328_i_TimeBombToKillParty_COPYPROTECTIONF</code> is reset to 0 in <code>F457_AA08_START_DrawEnabledMenus_COPYPROTECTIONF</code>.</li></ul></li></ul>
</body>
</html>